---
title: "R_Condition"
author: "seok"
date: "2018<eb>뀈 3<ec>썡 31<ec>씪"
output:
  pdf_document:
    toc: yes
    toc_depth: '3'
  html_document:
    number_sections: yes
    toc: yes
    toc_depth: 3
    toc_float: yes
---

# 제어문

 - R의 특징
 - 저장된 데이터를 한 번에 다루는 벡터연산을 수행한다는 점
 - 데이터 분석이기때문에 결측치(NA)가 중요한 주제로 떠오른다는 점
  
## IF, FOR, WHILE 문

 - IF문 구조는 다른 언어와 큰 차이가 없다.
 
```{r}
if ( TRUE ) {
print ('TRUE ')
print ('hello ')
} else {
print ('FALSE ')
print ('world ')
}
```

> for문

 - 변수 i가 주어진 벡터에 있는 1, 2, 3, ..., 10을 차례로 출력

```{r}
for ( i in 1:10) {
  print ( i )
}
```

> while문

 - 변수 i가 주어진 벡터에 있는 1, 2, 3, ..., 10을 차례로 출력

```{r}
i <- 0
while ( i < 10) {
  print ( i )
  i <- i + 1
}
```

---

# 연산

## 행렬 연산

- 행렬의 기본적인 연산인 합, 곱, 전치행렬(transpose), 역행렬을 다음과 같이 계산

```{r}
x <- matrix(1:4, nrow=2)
x
x + x
x %*% x
t(x)
solve(x)
```

## NA의 처리

- 결측치가 데이터에 포함되어 있을 경우 연산결과가 다음과 같이 NA로 바뀌어버리므로 주의가 필요하다.

```{r}
 NA & TRUE
 NA + 1
```

- 이러한 문제점을 해결하기위해 많은 R 함수들이 na.rm 인자를 받는다.
- na.rm 은 NA값이 있을때 해당값을 제거할 것인지를 지정하기 위한 목적이다.

```{r}
sum ( c (1 , 2 , 3 , NA ) )
sum ( c (1 , 2 , 3 , NA ) , na.rm = T )
```

- 잘알려진 머신 러닝 패키지 중 하나인 caret:  Classification and Regression Training은 na.omit, na.pass, na.fail등을 na.action이라는 인자로 받아서 NA 처리를 어떻게 할지 결정한다.
 
> na.omit, na.pass, na.fail의 차이를 보이는 예제
 
```{r}
x <- data.frame ( a = c (1 , 2 , 3) , b = c ( "a" , NA , "c" ) , c = c ( "a" , "b" , NA ) )
x
na.omit (x)
na.pass (x)
# na.fail (x)
# Error in na.fail.default ( x ) : missing values in object
```

- na.omit은 NA가 포함된 행을 제외하고, na.pass는 NA의 포함여부를 상관하지 않으며, na.fail은 데이터에 NA가 포함되어있을 경우 에러를 내보낸다.

- 따라서 NA를 어떻게 처리할지를 na.action으로 받았다면 ‘na.action(데이터 프레임)’을 실행해 현재 처리중인 데이터를 사용자가 원하는대로 정제할 수 있게 된다.


## 벡터 연산

 - 벡터 연산(Vectorized Computation 또는 Array Programming)은 벡터 데이터 타입을 지칭한다기보다는 벡터 또는 리스트를 한번에 연산하는 것을 말한다.
 
 - 벡터 연산이 중요한 이유는 for문등을 사용해 값을 하나씩  처리해나가는대신 벡터나 리스트를 한번에 처리하는 것이 더 효율적이고 편리하기 때문이다.
 
> 가장 간단한 예로 다음과 같이 벡터내 저장된 값을 1씩 증가시키는 경우

```{r}
x <- c(1, 2, 3, 4, 5)
x + 1
```

- 벡터끼리 연산하는 것도 가능하다.
-  진리값 (페이지 38)에서 설명하였듯이 벡터간 연산시에는 &&가 아니라 &를 사용한다.

```{r}
x <- c (1 , 2 , 3 , 4 , 5)
x + x
x == x
x == c(1, 2, 3, 5, 5)
c(T, T, T) & c(T, F, T)
```

- R의 함수들은 기본적으로 이러한 벡터 기반 연산을 지원한다.

- sum(), mean(), median()등은 벡터를 곧바로 인자로 받을 수 있다.

```{r}
x <- c(1, 2, 3, 4, 5)
sum(x) # 합계
mean(x) # 평균값
median(x) # 중간
```

- if - else문도 다음과 같이 한번에 적용가능하다.

> 2로 나눈 나머지를 사용해 짝수(even), 홀수(odd)를 판별

```{r}
x <- c (1 , 2 , 3 , 4 , 5)
ifelse ( x %% 2 == 0 , " even " , " odd " )
```

- 이외에도 lapply등의 함수를 사용한 함수적 프로그래밍 방식도 유용하다.

- 벡터 연산을 사용하면 데이터 프레임에 저장된 데이터 중 원하는 정보를 쉽게 얻을 수 있다.
- 기본 원리는 데이터 프레임에 TRUE 또는 FALSE를 지정해 특정 행을 얻어올 수 있다는 점을 이용하는 것이다.

> 1행, 3행, 5행을 TRUE로 하여 해당 행들만 데이터 프레임에서 
가져오는 예

```{r}
( d <- data.frame ( 
       x = c (1 , 2 , 3 , 4 , 5) , 
       y = c ( "a" , "b" , "c" , "d" , "e" ) 
     ) 
)
d [ c ( TRUE , FALSE , TRUE , FALSE , TRUE ) , ]
```

- 행의 선택 기준이 되는 TRUE, FALSE를 벡터 연산으로 만들어주면 특정 행을 선택할 수 있게 된다.

> x 값이 짝수인 행만 선택한 예

- %% 연산자는 주어진 숫자로 나눈 나머지를 뜻하므로 2로 나눈 나머지가 0인 행들을 선택하고 있다.

```{r}
d [ d$x %% 2 == 0 , ]
```

---

# 함수

## 함수의 정의

- 함수는 ‘함수명 <- function(인자, 인자, ....) { 함수 본문 }’ 로 정의

> 피보나치 함수를 구현한 예

```{r}
fibo <- function(n) {
  if (n==1 || n==2){
    return(1);
  }
  return (fibo(n-1) + fibo(n -2));
}
fibo(1)

fibo(5)
```

 - R에서 함수를 정의하는 방법은 이처럼 다른 언어의 함수 정의와 유사하지만 몇가지 차이점이 있다.
 
 - 첫째는 값 반환시 ‘return 반환값’같은 형태가 아니라 함수 호출을 하듯이 ‘return(반환값)’을 적어주어야한다는 점이다.
 
 - 두번째는 return()이 생략된다면 함수내 마지막 문장의 반환값이 함수의 반환값이 된다는 점
 
- 이 점을 사용하면 fibo()함수를 다음과 같이 고쳐쓸 수
있다.

```{r}
fibo <- function(n) {
  if(n==1 || n==2) {
    1
  } else {
    fibo(n-1) + fibo(n-2)
  }
}
```

 - 보통은 return()을 적어주는 편이 의도가 명확한 코드가 될 것이다.
 
- 함수를 호출할때는 인자의 위치를 맞춰서 값을 넘겨주는 방식, 또는 인자의 이름을 명명해서 넘겨주는 방식 두가지가 모두 가능하다. 

>  이 두가지 방식을 모두 보여주는 예

```{r}
f <- function(x, y) {
  print(x)
  print(y)
}
f(1, 2)
f(y=1, x=2)
```

- R의 함수들의 도움말을 살펴보면 ‘...'를 인자 목록에 적은 경우를 종종 볼 수 있다
- 함수의 인자에서 사용하는 ‘...’ 는 임의의 인자들을 받아서 다른 함수에 넘겨주는 용도로 주로 사용된다.
- 다음에 보일 함수 g()는 인자 z는 자기 자신이  처리하지만 나머지 인자들은 함수 f로 넘긴다.

```{r}
f <- function(x, y) {
  print(x)
  print(y)
}
g <- function(z, ...) {
  print(z)
  f(...)
}
g(1, 2, 3)
```

- 함수안에 또 다른 함수를 정의하여 사용할 수 있다.
- 중첩함수(Nested Function)이라고 부른다.

> 함수 f()안에 함수 g()를 정의하고 함수 f()안에서 이를 호출하여 사용하는 경우

```{r}
f <- function(x, y) {
  print(x)
  g <- function(y) {
    print(y)
  }
  g(y)
}
f(1, 2)
```


## 스코프(Scope)


- 코드에 기술한 변수 등을 지칭하는 이름이 어디에서 사용가능한지를 정하는 규칙을 스코프라고 한다.

- R에서는 대부분의 현대적인 프로그래밍 언어가 그러하듯이 lexical scope(또는 static scope)를 사용한다.

> 콘솔에서 변수를 선언하면 모든 곳에서 사용 가능한 변수가 된다.

```{r}
n <- 1
f <- function() {
  print(n)
}
f()
n <- 2
f()
```

> 함수 내부에서 변수 이름이 주어졌을 때 그 변수를 찾는 범위는 함수 내부가 우선된다.

- 만약 함수 내부에도, 전역 변수로도 없는 이름을 사용하면 에러가 된다.

```{r}
n <- 100
f <- function() {
  n <- 1
  print(n)
}
f()
```

> rm(list=ls())는 모든 객체를 삭제하는 명령

```{r}
rm(list=ls())
f <- function() {
  print(x)
}
# f()
# Error in print ( x ) : object 'x' not found
```

> 마찬가지로 함수 내부에 정의한 이름은 바깥에서 접근 할 수 없다.

```{r}
rm=(list=ls())
f <- function() {
  x <- 1
}
f()
# x
# Error : object 'x' not found
```

- 함수내에서 이름은 함수안의 변수들로 부터 먼저 찾는다.
- 같은 이유로 함수 인자의 변수명 역시 전역 변수에 우선한다.

```{r}
n <- 100
f <- function(n) {
  print(n)
}
f(1)
```

- 만약 함수 f마저도 변수 a를 갖고 있지 않다면 전역 변수 a를 사용하게 된다.

```{r}
a <- 100
f <- function(x) {
  g <- function(y) {
    print(y + a)
  }
  g(x)
}
f(1)
```

- 이러한 스코프 규칙은 의도치 않은 결과를 낳을 수 있다.

> 함수 f() 내에 변수 a가 있고 중첩된 함수 g에서 함수 f()내의 변수 a에 값을 할당하는 다음 코드

```{r}
f <- function() {
  print("f함수 선언")
  a <- 1
  g <- function() {
    print("-------")
    print("g함수 선언")
    a <- 2
    print(a)
    print("-------")
  }
  g()
  print(a)
}
print("f() 함수의 호출")
f()
```

- 함수 g()에서 함수 f()에 선언된 변수 a 에 2를 할당하려 하였지만 <- 는 함수 g() 내부에 새로운 변수 a를 만들고 그 변수에 2를 할당한다.

- f()에서 print(a) 가 수행될때 출력은 2가 아니라 1이 된다.

>  함수 g에서 함수 f내의 변수 또는 전역 변수를 접근하려면 <<- 를
사용해야한다.

```{r}
b <- 0
f <- function() {
  a <- 1
  g <- function() {
    a <<- 2
    b <<- 2
    print(a)
    print(b)
  }
  g()
  print(a)
  print(b)
}
f()
```

- g() 내에서 <<-를 사용한 값의 할당은 함수 f()에 선언된 a와  전역변수인 b에대해 이루어졌다.

---

# 객체

## 값에 의한 전달
- R에서는 모든 것이 객체이다.
- 객체는 함수 호출시 일반적을 값으로 전달된다.
- 이를 변수에 대한 참조(Reference)에 의한 방식에 대비해 값에 의한 전달(Pass By Value)이라고 한다.
- 값으로 전달된다는 말은 객체가 복사되어 함수로 전달된다는 의미이다.

> 데이터 프레임을 함수에 주었을 때 함수 내부에서 수행한 변경은 원래 객체에는 반영되지 않는다.

- 함수 f안에서의 df2란 f를 호출한 측에서 넘긴 df객체를 가리키는 참조가 아니라 넘겨받은 df를 복사한 새로운 df2이기 때문이다.
```{r}
f <- function(df2) {
  df2$a <- c(1, 2, 3)
}
df <- data.frame(a=c(4, 5, 6))
f(df)
df
```

- 인자로 받은 df 를 수정하여 이를 반영하려면 함수 f에서 다음과 같이 return을 해주어야한다.

> return을 사용하여 값을 반환하는 예

```{r}
f <- function ( df ) {
  df$a <- c (1 , 2 , 3)
  return ( df )
}
df <- data.frame(a=c(4, 5, 6))
df <- f(df)
df
```

- 특별한 객체(예를들어 네트워크 접속 connection이나 파일 입출력 connection 등)를 제외하고는 객체의 상태가 함수에 의해 직접적으로 수정되지 않는다. 
- 따라서 어떤 함수를 호출하더라 더 인자로 넘긴 객체가 수정되지 않음을 보장받는다.

```
R을 포함한 현대적 언어들은 함수 호출시 곧바로 객체를 복사하기 보다는 객체의 값을 바꿀 필요가 있을 때만 복사를 수행하는 Copy On Write 기법을 사용한다. 
Copy on Write에서는 데이터 프레임 등의 객체를 어떤 함수에 넘겼을 때 그 함수가 객체 내부 값을 바꾸는 시점에 이르러서야 값이 수정된 새로운 복사본을 만든다.
```


## 객체의 불변성

- R의 객체는 (거의 대부분의 경우에) 불변이다.
- 객체라는 용어를 R에서 메모리에 할당된 데이터 구조들을 뜻한다고 생각하면 된다.
- 벡터를 하나 메모리에 만들었으면 그것이 객체이고, 리스트를 하나 만들었어도 객체이다.
- 이런 객체들은 불변(immutable)이다. 
- 따라서 마치 객체를 수정하는 것 처럼 보이는 다음 코드는 실제로 원래
객체를 변경하는 것은 아니다.

```{r}
a <- list ()
a$b <- c (1 , 2 , 3)
```
- 실제로 일어나는 일은 a를 복사한 새로운 객체 a’을 만들고 a’에 필드
b를 추가하고 그 필드에 c(1, 2, 3) 을 채워넣은 다음, 변수명 a가 a’을 가리키도록 하는 것이다.

- 앞서 벡터 연산 (페이지 71)에서 벡터 기반 연산을 사용하는 것이 for 등의 반복문을 사용하는 것보다 효율적이라고 한 바 있다.
- 그 이유 중 하나가 바로 객체가 불변이라는 점 때문이다.

- 예를들어 for 문 안에서 벡터의 인자를 하나씩 바꾸는 다음 코드는 v[i] 값을 1씩 증가시킬때마다 i번째 값이 수정된 벡터를 매번 새로 만들고 이를 매번 v에 할당한다. 따라서 1000개의 새로운 객체를 생성하는 비효율이 발생한다.

```{r}
v <- 1:1000
for( i in 1:1000) {
  v[i] <- v[i] + 1
}
```

-  다음 코드는 v내 전체 값을 1 만큼 증가시킨 객체를 한개 만든 다음 이를 v에 할당한다.

```{r}
 v <- 1:1000
 v <- v + 1
 v
```

-  벡터 연산이 더 빠른 이유는 이러한 메모리 사용 최적화의 문제와도 관련이 있다. 이를 확인하는 한가지 방법은 다음 코드를 실행해 보는 것이다.

```{r}
rm(list=ls()) # 모든 선언된 변수를 삭제하기 위한 명령
gc() # 가베지 컬렉션(Garbage Collection)을 호출해 현재 사용하지 않는 변수들을 메모리에서 삭제하기 위한 명령
v <- 1:9999
for( i in 1:9999) {
  for( j in 1:9999) {
    v[j] <- v[j] + 1
  }
}
# for 문이 수행되는 동안 작업 관리자를 살펴보면 메모리 사용량이 서서히 증가함을 알 수 있다.
```

## 모듈(Module) 패턴
- 모듈이란 외부에서 접근할 수 없는 데이터와 그 데이터를 제어하기위한 함수로 구성된 구조물을 말한다.
- 패턴이란 정형화된 코딩 기법을 뜻한다.

```
- 모듈 패턴을 사용하여 데이터를 외부에서 직접 접근 할 수 없게 하면 데이터의 내부 구현이숨겨진다. 
- 반대로 말하자면 모듈의 사용자가 모듈 내부에서 데이터가 어떻게 저장되는지 더이상 신경 쓸 필요가 없게된다는 의미이다.
- 사전에 정의된 함수로만 그 데이터를 다룰 수 있게 하면 데이터의 내부 구조를 잘 모르는 사용자가 데이터를 함부러 건드려서 손상시키는 일을 막을 수 있다.
- 모듈의 사용자는 내부 구조는 건들 수 없고 외부로 노출된 함수만 불러쓰고 있는 상태가 되므로, 모듈의 제작자는 해당 함수가 이전과 같은 결과를 내놓기만 한다면 함수의 내부구조나 데이터 구조를 마음대로 바꿀 수 있다.
```

### 큐(Queue)

- 큐는 먼저 들어온 데이터를 먼저 처리하는데 사용하는 자료구조이다.

```
• Enqueue: 줄의 맨 뒤에 데이터를 추가한다.
• Dequeue: 줄의 맨 앞에 있는 데이터를 가져온다. 가져온 데이터는 줄에서 빠진다.
• Size: 줄의 길이, 즉 자료구조내에 저장된 데이터의 수를 반환한다.

```

```{r}
q <- c ()
q_size <- 0

enqueue <- function ( data ) {
  q <<- c (q , data)
  q_size <<- q_size + 1
}

dequeue <- function () {
  first <- q [1]
  q <<- q [ -1]
  q_size <<- q_size - 1
  return ( first )
}
size <- function () {
  return ( q_size )
}
```
```
-  큐에 저장될 데이터는 벡터 q를 사용해 저장하고 있다.
- q size는 큐에 저장된 데이터 수를 기록하는 목적으로 쓰였다.
- 함수 enqueue()는 q에 이미 저장되어있는 데이터에 인자로 받은 데이터를 추가하여 다시 변수 q에 할당하였다.
- 이 때 <<-를 사용해 전역변수에 있는 q를 직접 접근하게 하였다. 마지
막으로 q size의 값을 1 증가시켰다.
- 함수 dequeue()는 q 에 저장된 데이터중 첫번째 요소를 first에 저장하고, q에는 이 데이터를 제외한 데이터를 저장한다음 first를 반환하였다. 이 때 q size 를 1 감소시킨다.
- 함수 size()는 q 의 길이인 q size를 반환한다.
```

```{r}
enqueue(1)
enqueue(3)
enqueue(5)
print(size())
print(dequeue())
print(dequeue())
print(dequeue())
print(size)
```

### 큐(Queue) 모듈의 작성

- 앞 절에서 작성한 큐 코드의 작성자는 큐의 맨뒤에 데이터를 저장하고 큐의 맨 앞에서 데이터를 가져오도록 설계하였다.
- 하지만 q라는 변수가 전역적으로 선언되어있으므로 이 함수를 거치지
않고 외부에서 데이터를 조작해버릴 수 있다.

- 이 때 데이터의 무결성이 다음과 같이 깨질 수 있다.
```{r}
 enqueue (1)
 q <- c (q , 5)
 print ( size () )
 dequeue ()
 dequeue ()
 size ()
```

-  q의 외부에서 q에 직접적으로 값을 할당해버린탓에 실제로는 q내부에 데이터가2개 저장되어있지만 size()를 호출했을 때 크기가 1로 나타나는 문제가 있다.

- 이러한 문제를 막기위한 방법은 큐 코드 전체를 하나의 함수로 감추어 모듈화 시키는 것이다.

```{r}
queue <- function () {
  q <- c ()
  q_size <- 0
  
  enqueue <- function ( data ) {
    q <<- c (q , data )
    q_size <<- q_size + 1
  }
  
  dequeue <- function () {
    first <- q [1]
    q <<- q[ -1]
    q_size <<- q_size - 1
    return ( first )
  }
  
  size <- function () {
    return ( q_size )
  }
   return (list(enqueue = enqueue , dequeue = dequeue , size = size))
}
```

- 이 코드가 앞서와 다른 점이라면 q와 q size가 이제 queue 함수내의 지역변수라는 점이다.
- 함수 enqueue(), dequeue(), size()는 함수 queue()의 반환값이 되었고 이 값은 리스트로 반환되고 있다.

```{r}
q <- queue ()
q$enqueue (1)
q$enqueue (3)
q$size ()
q$dequeue ()
q$dequeue ()
q$size ()

```

- queue() 함수 호출시 만들어지는 queue() 함수 내부의 지역변수 q와 q size 가 생성되는 공간은 queue() 함수 호출때마다 매번 새로 생성된다.
- 즉 queue()를 다음과 같이 여러개 만들어서 사용해도 데이터가 서로 섞이지 않게 된다.

```{r}
 q <- queue ()
 r <- queue ()
 q$enqueue (1)
 r$size ()
 r$enqueue (3)
 q$dequeue ()
 r$dequeue ()
 q$size ()
 r$size ()
```

- 코딩 기법을 모듈 패턴이라고 하며 Software for Data Analysis에 소개되어있다.


## 객체의 삭제

- 메모리 상에 만들어진 객체의 목록을 얻는 함수는 ls()이다.

```{r}
x <- c (1 , 2 , 3 , 4 , 5)
ls ()
```

- 때에 따라서는 메모리 상에 생성해둔 객체를 삭제할 필요가 있을 수 있다.
- 객체의 삭제는 rm()을 사용한다.

```{r}
rm("x")
ls()
```

- 모든 객체를 한번에 메모리에서 삭제하는 방법
```{r}
 rm ( list = ls () )
```