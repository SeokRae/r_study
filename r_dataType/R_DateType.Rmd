---
title: "R_dataType"
author: "SeokRae"
date: "2018년 4월 20일"
output:
  html_document:
    number_sections: yes
    toc: yes
    toc_depth: 3
    toc_float: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# 데이터타입
 - 벡터(vector), 행렬(matrix), 데이터프레임(dataframe), 리스트(list)
 
## 변수

 - R의 변수명은 알파벳, 숫자, '_', '.' 로구성
 - 첫글자는 문자 또는 '.'으로 시작
 - 만약 '.'으로 시작한다면 '.'뒤에는 숫자가 올 수 없다.

> **올바른 변수명**

```{r}
# a
# b
# a1
# a2
# .x
```

> **올바르지 않은 변수명**

```{r}
# 2a
# .2
```

> **변수에 값을 할당**
```{r}
x <- 2
x <<- 2
x = 2
```

## 스칼라
 - R의 기본형은 벡터이므로 스칼라자료 '길이 1의 벡터'로 볼 수 있다.

### 숫자
 - 정수, 부동 소수 등이 자연스럽게 지원된다.
 
 ```{r}
 a <- 3
 b <- 4.5
 c <- a + b
 print(c)
 ```
 
### NA
 - 데이터에 값이 존재하지 않는다면 NA로 표시할 수 있다.

```{r}
one <- 100
two <- 75
three <- 80
four <- NA
is.na(four) # 어떤 변수에 NA 가 저장되어 있는지 is.na() 함수로 확인가능
```

### NULL
 - NULL은 NULL 객체를 뜻하는데, 변수가 초기화 되지 않은 경우 등에 사용
 - 결측치(NA)와 구분하여 생각
 - 어떤 변수에 NULL이 할당되었는지 **is.null()**을 사용하여 판단
```{R}
x <- NULL
is.null(x)
is.null(1)
is.null(NA)
is.na(NULL) # 조건문의 조건에 사용하기 전, 어떤 값을 넣어야 할지 알 수 없어 NULL로 초기화
```

### 문자열
 - 한 개 문자에 대한 데이터 타입은 없다. 대신 문자열로 모든 것을 처리
```{r}
a <- "hello"
print(a)
```

### 진리값
 - TRUE, T는 모두 참값을 말한다.
 - FALSE, F 는 거짓을 말한다.
 - 진리값에는 &(AND), |(OR), !(NOT) 연산자를 사용할 수 있다
```{r}
TRUE & TRUE
TRUE & FALSE
TRUE | TRUE
TRUE | FALSE
!TRUE
!FALSE
```

 - TRUE와 FASLE는 예약어(reversed words)이다.
 - T, F는 각각 TRUE와 FASLE로 초기화된 전역 변수이다.
 - T에 FASLE를 할당하는 것이 가능
```{r}
T <- FALSE
# TRUE <- FALSE # TRUE에는 FALSE를 할당할 수 없다.
```

 - AND나 OR연산자에는 &, | 외에도 &&d와 ||가 있다.
 - &, |는 boolean이 저장된 벡터(vector)끼리의 연산시 각 원소간 계산을 한다는 점
```{r}
c(TRUE, FALSE) & c(TRUE, FALSE)
```

 - 반면 &&은 한 개의 boolean 값끼리의 연산을 하기 위한 연산자이다.
```{r}
c(TRUE, FALSE) && c(TRUE, FALSE)
```

 - 또 &&, ||는 short-circuit을 지원
 - A && B 형태의 코드가 있을 때 A가 만약 TRUE라면 B도 평가하지만 A가 FALSE라면 B를 평가하지 않는다.
 - 벡터 또는 리스트 내 원소를 한 번에 비교하는 연산이 많으므로 &나 |가 유용하다.
 
### 요인(Factor)
 - 요인(Factor)은 범주형(Categorical) 변수를 위한 데이터 타입이다.
```{r}
sex <- factor("m", c("m", "f"))
sex
```
 - 'sex' 변수를 출력, 값은 m, 변수가 가질 수 있는 수준은 m과 f의 2개
 - 'sex'에는 m, f 2개 값을 갖는 범주에서 m이 선택되어 저장되었다.

 - Factor 변수는 nlevels()로 범주의 수를 구할 수 있다.
 - levels()로 범주 목록을 알 수 있다.

```{r}
nlevels(sex) # 범주의 수
levels(sex) # 범주 목록
```

 - 이를 응용하여 각 범주의 값을 구할 수 있다.

```{r}
levels(sex)[1]
levels(sex)[2]
```

 - Factor 변수에서 level의 값을 직접적으로 수정하고자 하는 경우
```{r}
sex
levels(sex) <- c("male", "female") # sex 내에 값을 직접적으로 수정
sex
```

 - factor()는 기본적으로 데이터에 순서가 없는 명목형 변수(Normal)를 만든다.
 - 범주형 데이터에서 순서를 부여하고자 하는 경우 순서형(Ordinal) 변수로 만든다.
```{r}
ordered( c("a", "b", "c") ) # 순서형(Ordinal) 변수로 만들기 위한 ordered()
factor( c("a", "b", "c"), ordered=TRUE ) # 순서형(Ordinal) 변수로 만들기 위해 factor() 호출시, ordered=TRUE를 지정
```

> **중간정리**
```{}
1. 변수
2. 스칼라
 2.1 숫자의 대입
 2.2 NA(결측치)
  - is.na(변수명) # 어떤 변수에 NA가 저장되어 있는지 확인하는 함수
 2.3 NULL # 변수가 초기화 되지 않은 경우에 사
  - is.null(변수명) # 어떤 변수에 NULL이 할당되었는지 확인하는 함수
 2.4 문자열
 2.5 진리값 (boolean)
 2.6 요인(Factor)
  - nlevels() # 범주의 수
  - levels() # 범주 목록
  - levels(범주)[n] # n은 인덱스 값을 통해 각 범주의 값을 알 수 있다.
  - levels(범주) <- c("값", "값") # 범주에 값을 직접적으로 수정 가능
  - ordered( c("값", "값", "값") ) # ordered함수에 벡터값 대입으로 순서형(Ordinal) 변수로 만들 수 있다.
  - factor( c("값", "값", "값") ) # factor()호출 시 ordered=TRUE 지정으로 순서형(Ordinal) 변수로 만들 수 있다.
```


## 벡터(Vector)

### 벡터의 정의
 - c() 안에 원하는 인자들을 나열하여 정의
```{r}
x <- c(1,2,3,4,5)
x
```

 - 나열하는 인자들은 **한 가지 유형의 스칼라 타입**이어야 한다.
 - 만약 다른 타입의 데이터를 섞어서 벡터에 저장하면 이들 데이터는 한가지 타입으로 **자동 형변환** 된다.
 
> 자동 형변환 되는 예
```{r}
x <- c("1", 2, "3")
x
```

 - 벡터는 중첩될 수 없다.
 - 따라서 벡터 안에 벡터를 정의할 경우 단일 차원의 벡터로 변경된다.
 - 이를 해결하기 위해서는 리스트(List)를 사용해야 한다.
```{r}
c(1,2,3)
c(1,2,3, c(1,2,3))
```

 - 숫자형 데이터의 경우 start:end 형태로 시작값부터 끝값까지의 값을 갖는 벡터를 만들 수 있다.
 - seq(from, to, by) 형태역시 가능하다.
 
```{r}
# start:end 형태로 시작값부터 끝값까지의 값을 갖는 벡터만들기
x <- 1:10 
x
x <- 5:10
x
# seq(from, to, by) 형태로 벡터만들기
seq(1, 10, 2) 
```

 - seq_along(파라미터)은 인자로 주어진 데이터의 길이만큼 1,2,3, ..., N으로 구성된 벡터를 반환한다.
 - seq_len()은 N값이 인자로 주어지면 1, 2, ..., N으로 구성된 벡터를 반환한다.
```{r}
seq_along(c("a", "b", "c"))
seq_len(3)
```

 - 벡터의 각 셀에는 이름을 부여할 수 있다. names()에 원하는 이름을 벡터로 넘겨주면 된다.
```{r}
x <- c(1,3,4)
names(x) <- c("kim", "seo", "park")
x
```

### 벡터내 데이터 접근
 - 벡터는 [ ] 안에 인덱스를 적어서 각 요소를 가져올 수 있다.
```{r}
x <- c("a", "b", "c")
x[1]
x[3]
```

 - 또 '-인덱스'와 같이 음수의 인덱스를 사용해 특정 요소만 제외할 수도 있다.
```{r}
x <- c("a", "b", "c")
x[-1]
x[-2]
```

 - 벡터의 여러 위치에 저장된 값을 가져오려면 '벡터명[색인 벡터]'의 형식을 사용한다.
```{r}
x <- c("a", "b", "c") # 벡터 값 생성
x[c(1,2)] # 인덱스 1과 2의 벡터 값 출력
x[c(1,3)] # 인덱스 1과 3의 벡터 값 출력
```

 - x[start:end]를 사용하여 start부터 end까지(end에 위치한 요소 포함)의 데이터를 볼 수도 있다.
```{r}
x <- c ( "a" , "b" , "c" ) # 벡터 값 생성
x[1:2] # 1 ~ 2까지의 벡터 값 출력
x[1:3] # 1 ~ 3까지의 벡터 값 출력
```

 - 벡터의 각 셀에 names()를 사용해 이름을 부여해 두었다면, 이 이름을 사용해 데이터를 접근할 수 있다.
```{r}
x <- c(1,3,4)
names(x) <- c("kim", "seo", "park")
x
x["seo"] # 벡터값의 "seo"라는 이름을 통해 값을 확인
x[c("seo", "park")] # 벡터값의 "seo", "park"라는 이름을 통해 값을 확인
```

 - 벡터에 부여된 이름만 보려면 이름을 부여할 때와 마찬가지로 names()를 사용한다.
```{r}
names(x)[2]
```

 - 벡터의 길이는 length(), NROW()를 통해 알 수 있다.
 - nrow()는 행렬의 행의 수를 알려주는 함수
 - NROW()는 인자가 벡터인 경우 벡터를 n행 1열의 행렬로 취급해 길이를 반환
```{r}
x <- c("a", "b", "c")
length(x) # 벡터의 길이를 알려주는 함수
nrow(x) # 행렬의 행의 수를 알려주는 함수이기 때문에 NULL 값 나옴
NROW(x) # 벡터를 n행 1열의 행렬로 취급하여 길이를 반환
```

### 벡터 연산
 - %in% 연산자는 어떤 값이 벡터에 포함되어 있는지를 알려준다.
```{r}
"a" %in% c("a", "b", "c")
"d" %in% c("a", "b", "c")
```
 - 벡터를 집합(set)으로 취급해 집합간 합집합, 교집합, 차집합을 계산할 수 있다.
```{r}
setdiff ( c ( " a " , " b " , " c " ) , c ( " a " , " d " ) ) # 차집합
union ( c ( " a " , " b " , " c " ) , c ( " a " , " d " ) ) # 합집합
intersect ( c ( " a " , " b " , " c " ) , c ( " a " , " d " ) ) # 교집합
```

 - 집합간 비교는 setequal()을 사용
```{r}
# 집합 단위 비교
setequal ( c ( " a " , " b " , " c " ) , c ( " a " , " d " ) )
setequal ( c ( " a " , " b " , " c " ) , c ( " a " , " b " , " c " , " c " ) ) 
```

### seq
 - seq(시작값, 마지막값, 증가치)의 형태로 호출하여 벡터를 표현
 - 증가치는 생략가능
```{r}
seq(1, 5)
seq(1, 5, 2)
```

 - 보다 짧게 표현
```{r}
1:5
```

### rep
 - 특정 값들이 반복된 벡터를 만들기
```{r}
rep (1:2 , 5) # 1,2를 5회 반복하는 벡터
rep (1:2 , each =5) # 1이 5회, 2가 5회 반복하는 벡터
```

## 리스트(List)
 - 다른 언어에서 흔히 보는 해싱 또는 딕셔너리에 해당
 - 키, 값 형태의 데이터를 담는 연관 배열(associative array)

### 리스트의 정의
 - 리스트는 list(키=값, 키=값, ...) 형태로 데이터를 나열해 정의
```{r}
x <- list(name="foo", height=70) # 리스트에 스칼라 값으로 저장
x
x <- list(name="foo", height=c(1, 3, 5)) # 리스트에 벡터값으로 저장
x
```
 - 리스트에는 다양한 값들을 혼합해서 저장할 수 있다.
 - 리스트 안에 리스트를 중첩하는 것도 가능
```{r}
list(a=list(val=c(1,2,3)), b=list(val=c(1,2,3,4)))
```

### 리스트내 데이터 접근
 - 리스트는 '$키' 형태로 각 키들이 나열된다.
 - 데이터는 '리스트변수명$키'와 같이 접근한다.
 - 각 요소를 순서대로 **'리스트변수[[인덱스]]'**와 같이 접근할 수도 있다.
```{r}
x <- list(name="foo", height=c(1, 3, 5))
x$name # 리스트 x의 키 name의 값을 보기
x$height # 리스트 x의 키 height 값을 보기
x[[1]] # 리스트의 첫 번째 키의 값을 보기
x[[2]] # 리스트의 두 번째 키의 값을 보기
```

 - 주의할 점은 값을 가졍기 위해서 '[[인덱스]]'의 형태로 적어야지 '[인덱스]'로 해서는 안된다.
 - '[인덱스]'의 형태는 각 값이 아니라 '(키,값)'을 담고 있는 서브 리스트를 반환한다.
```{r}
x[1] #리스트x의 첫 번째 키:값을 반환
x[2] #리스트x의 두 번째 키:값을 반환
```

## 행렬(Matrix)
 - 벡터와 마찬가지로 행렬에는 한 가지 유형의 스칼라만 저장할 수 있다.
 
### 행렬의 정의
 - 행렬 matrix()를 사용해 표현
```{r}
matrix(c(1:9), nrow=3)
matrix(c(1:9), ncol=3)
```
 - 행렬값을 나열한 뒤 ncol을 사용해 열의 수를 지정하거나 nrow를 사용해 행의 수를 지정하면 된다.
 - 행렬값이 좌측 열부터 채워져오는데, 대신 행렬값을 위쪽 행부터 채우고 싶다면 byrow를 사용한다.
```{r}
matrix(c(1:9), nrow=3, byrow=TRUE) # byrow=T는 안먹혀서 TRUE로 수정
```

 - 행렬의 행과 열에 명칭을 부여하고 싶을 경우 dimnames()를 사용
```{r}
matrix( c(1:9)
        , nrow = 3
        , dimnames = list( c("item1", "item2", "item3")
                          ,c("feature1", "feature2", "feature3")
                          )
        )
```

### 행렬내 데이터 접근
 - 행렬의 각 요소는 '행렬이름[행인덱스, 열인덱스]'로 접근할 수 있다.
 - 인덱스는 벡터의 경우와 마찬가지로 1부터 시작
```{r}
x <- matrix ( c (1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9) , ncol =3)
x
x[1,1]
x[1,2]
x[2,1]
x[2,2]
```

 - 벡터와 마찬가지로 '-인덱스'와 같이 표현해 특정 행/열을 제외하거나 '시작인덱스:끝인덱스'로 특정 범위의 데이터만 가져올 수도 있다.
 - 특정 행이나 열의 전부를 가져오고 싶다면 행이나 열쪽에는 아무런 인덱스도 기재하지 않으면 된다.
```{r}
x[1:2, ] # 1,2행의 데이터만 추출
x[-3, ] # 3행을 제외하는 방법
```

 - 인덱스를 벡터에 넣어 나열
```{r}
x [ c (1 , 3) , c (1 , 3) ]

```

 - dimnames를 통해 행과 열에 이름을 부여했다면 그 이름을 직접 사용가능
```{r}
x <- matrix( c(1:9)
             , nrow=3
             , dimnames = list(  c ( "item1", "item2", "item3" )
                                 , c ( " feature1 " , " feature2 " , " feature3 " )
                              )
             )
x
x["item1", ]
```

### 행렬의 연산
 - 행렬에 스칼라를 곱하거나 나누는 연산은 * 나 /를 사용한다.

> 행렬의 연산

```{r}
x <- matrix( c(1:9)
             , nrow=3
             )
x*2 # 행렬에 스칼라를 곱하는 연산
x/2 # 행렬의 스칼라를 나누는 연산
```

> 행렬끼리 계산

```{r}
x <- matrix( c(1:9)
             , nrow=3
             )
x + x # 행렬끼리의 덧셈
x - x # 행렬끼리의 뺄셈
x %*% x # 행렬끼리의 곱
```

> 역행렬 계산
```{r}
x <- matrix ( c (1 , 2 , 3 , 4) , ncol =2)
solve(x) # 행렬의 역행렬
x %*% solve(x) # 역행렬 계산
```

> 전치행렬 t()

```{r}
x <- matrix ( c (1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9) , nrow =3)
x
t(x)
```

> 행렬의 차원
 - ncol(), nrow()
```{r}
x <- matrix ( c (1 , 2 , 3 , 4 , 5 , 6) , ncol =3)
x
ncol(x)
nrow(x)
```

## 배열

### 배열 정의
 - matrix가 2차원 행렬이라면 배열(array)은 n차원 행렬이다.
```{r}
matrix(1:12, ncol = 4) # 행렬을 4열로 출력
array(1:12, dim=c(3,4)) # 배열을 3행 4열로 출력
array(1:12, dim=c(2,2,3)) # 2x2x3 차원의 배열
```

### 배열 데이터 접근
 - 배열의 차원은 dim() 함수를 통해 알 수 있다.
```{r}
x <- array (1:12 , dim = c (2 , 2 , 3) )
x
x [1 , 1 , 1] # 배열의 값 접근
x [1 , 2 , 3]
x [ , , 3]
dim ( x ) # 배열의 차원을 알 수 있는 dim() 함수
```

## 데이터 프레임(Data Frame)
 - 데이터 프레임은 R에서 가장 중요한 자료형
 - 행렬과 비슷한 모습이지만 행렬과 달리 다양한 변수, 관측치(observations), 범주 등을 표현하기 위해 특화되어 있다.

### 데이터 프레임 정의
 - 데이터 프레임은 data.frame()을 사용해 정의
```{r}
d <- data.frame(
  x=c(1:5)
  , y=c(2, 4, 6, 8, 10)
)
d
```
 - 각 열의 데이터 타입이 같다면 여러가지 데이터 타입을 혼용해서 사용할 수 있다.
```{r}
d <- data.frame(
  x=c(1,2,3,4,5)
  , y=c(2,4,6,8,10)
  , z=c('M', 'F', 'M', 'F', 'M')
) # Factor 형태의 z열 추가
d
```

 - 이미 정의된 데이터 프레임에 새 열을 추가
 - '$열이름 <- ...'과 같은 형식으로 새로운데이터 추가
```{r}
d <- data.frame(
  x = c (1 , 2 , 3 , 4 , 5)
  , y = c (2 , 4 , 6 , 8 , 10)
  , z = c ('M', 'F', 'M', 'F', 'M')
)
d$v <- c(3, 6, 9, 12, 15)
d
```

### 데이터 프레임 접근
 - 데이터 프레임의 각 열은 '$변수명'으로 접근할 수 있으며, 행이나 열의 인덱스를 사용해서도 데이터에 접근할 수 있다.
```{r}
d <- data.frame(
  x=c(1,2,3,4,5)
  , y=c(2,4,6,8,10)
)
d$x
d[1,] # 데이터프레임 d의 1행 값들 출력
d[1, 2] # 데이터프레임 d의 1행 2열값 출력
```

 - 벡터로 인덱스를 지정하거나, 또는 제외할 행 또는 열을 -로 표시할 수 있다.
```{r}
d[c(1,3), 2] #데이터프레임 d의 1,3행 2열 출력
d[-1, -c(2,3)] # 데이터프레임 d의 1행, 2,3열 제외한 값 출력
d[ , c("x", "y")] # 데이터프레임 모든 행, 'x','y'열을 출력
d[ , c("x")] # 데이터프레임 모든 행, 'x'열을 출력
```

 - x컬럼만 선택했을 때는 data.frame의 일반적인 모양인 표 형태가 아닌 벡터처럼 결과가 나왔다. 
 - 컬럼의 차원이 1이 되면 자동으로 데이터 프레임이 아닌 벡터로 값을 반환하기 때문이다.
 - 이를 해결하기 위한 방법은 drop=FALSE옵션을 지정한다.
```{r}
d[ , c("x"), drop=FALSE]
```

 - 데이터 프레임부터는 구조가 복잡해지므로 str()과 head() 함수를 알아둘 필요가 있다.
 - str()는 R 객체의 내부 구조를 보는데 사용되는 함수
```{r}
str(d)
```

 - 통상 R에서의 처리는 데이터 프레임을 기본 타입으로 하여 진행되므로 데이터 프레임에 많은 양의 데이터를 저장하게 된다.
 - 데이터의 일부만 보기 위한 head()
```{r}
d <- data.frame(
  x=1:1000
)
head(d)
```

 - **데이터 프레임의 행 이름, 열 이름은 각각 rownames(), colnames() 함수로 지정**할 수 있다.
```{r}
x <- data.frame(1:3)
x
# 또는 names()를 사용핻도 colnames()와 같은 결과를 얻는다.
colnames(x) <- c("val") # names(x) <- c("val")
x
rownames(x) <- c("a", "b", "c")
x
```

 - 주어진 값이 벡터에 존재하는지를 판별하는 %in% 연산자를 이용하면 특정 열만 선택하는 작업을 보다 손쉽게 할 수 있다.
```{r}
# 명령의 처음과 끝에 괄호를 사용할 경우 결과 값을 출력까지 한다.
(d <- data.frame(
  a=1:3
  , b=4:6
  , c=7:9
))
d[, names(d) %in% c("b", "c")] # 데이터프레임에서 특정 열의 값들만 출력
d[, !names(d) %in% c("a")] # ! 연산자를 사용해 특정 열의 값들만 제외
```

## 타입 판별
 - 반환된 결과의 타입이 무엇인지 분명하지 않을 떄 사용
```{r}
class(c(1,2)) # 벡터에 저장된 데이터 타입에 따라 numeric, logical, character, factor등이 될 수 있다.
class(matrix(c(1,2))) 
class(list(c(1,2)))
class(data.frame(x=c(1,2)))
```
 - 데이터 타입을 str()문으로도 확인할 수 있다.
```{r}
str(c(1,2)) # 차원이 [1:2] 1차원에 값이 2개
str(matrix(c(1,2))) # 차원이 [1:2, 1] 2차원이고 2행 1열
str(list(c(1,2)))
str(data.frame(x=c(1,2)))
```

 - is.factor, is.numeric (숫자 벡터), is.character(문자열 벡터), is.matrix, is.data.frame 등의 'is.*' 형태의 함수들을 사용해 데이터의 타입을 확인할 수 있다.
```{r}
is.numeric(c(1,2,3))
is.numeric(c('a', 'b', 'c'))
is.matrix(matrix(c(1,2)))
```

## 타입 변환
 - 타입간의 변환은 각 타입에 인자로 변환할 데이터를 넘기거나 'as.*' 종류의 함수를 사용하여 수행할 수 있다.

> 행렬을 data.frame()의 인자로 넘겨 데이터 프레임으로 형변환
```{r}
x <- data.frame(
  matrix(c(1,2,3,4), ncol=2)
)
x
colnames(x) <- c("X", "Y")
x
```

 - 리스트를 데이터 프레임으로 변환
```{r}
data.frame(
  list(
    x=c(1,2)
    , y=c(3,4)
  )
)
```

 - as.numeric, as.factor, as.data.frame, as.matrix 등의 함수를 사용한 형 변환이 가능하다.

> 문자열 벡터를 Factor로 변환했다가 다시 숫자형 벡터로 변환
```{r}
x <- c("m", "f")
# f가 알파벳 순서상 m보다 앞이므로 as.factor(c("m", "f"))의 결과에서 levels이 "f m"으로 정해진다.
# 따라서 as.numeric()에 "m", "f"의 factor들을 주면 levels 순서에 따라 2, 1이 반환된다.
as.factor(x) 
as.numeric(as.factor(x))
```

 - levels의 순서를 "m", "f"로 하고 싶다면 factor() 함수를 써야 한다.
```{r}
# as.factor()는 levels 파라미터가 존재하지 않으므로, 이와 같은 순서 지정은 factor()를 통해서만 가능하다.
# 따라서 상황에 따라 적절한 함수를 사용해 형 변환을 수행해야 한다.
factor(c("m", "f"), levels=c("m", "f"))
```
